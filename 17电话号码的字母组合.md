给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。  
示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"].   
示例 2：  

输入：digits = ""
输出：[].   
示例 3：  

输入：digits = "2"
输出：["a","b","c"]. 
 

提示：

0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 运用回溯法(Dfs)：  
## 回溯法： = 决策树的遍历过程  
考虑三个问题：  
* 路径：也就是*已经做出的选择*。
* 选择列表：也就是你当前*可以做的选择*。
* 结束条件：也就是到达决策树底层，*无法再做选择的*条件
## 框架：
```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```
46.全排列（中等）
51.N皇后（困难）




# 解答：
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits :
            return list()
        comprisedD = {
            "2" :"abc",
            "3" :"def",
            "4" :"ghi",
            "5" :"jkl",
            "6" :"mno",
            "7" :"pqrs",
            "8" :"tuv",
            "9" :"wxyz"
        }
        def traceback(index):
            # 结束条件：
            if index == len(digits):
                #注意： 这里要写成这样，如果直接.append(path), 会输出嵌套列表
                results.append("".join(path))
            else:
                #输入的数字
                d = digits[index]
                # 选择列表：
                for i in comprisedD[d]:
                #路径选择：
                    path.append(i)
                    traceback(index+1)
                    path.pop()

        path = list()
        results = list()
        traceback(0)
        return results
        
```
