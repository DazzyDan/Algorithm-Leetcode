给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。  
示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"].   
示例 2：  

输入：digits = ""
输出：[].   
示例 3：  

输入：digits = "2"
输出：["a","b","c"]. 
 

提示：

0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 运用回溯法(Dfs)：  
## 回溯法： = 决策树的遍历过程  
考虑三个问题：  
* 路径：也就是*已经做出的选择*。
* 选择列表：也就是你当前*可以做的选择*。
* 结束条件：也就是到达决策树底层，*无法再做选择的*条件
## 框架：
```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```





# 解答：
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits :
            return list()
        comprisedD = {
            "2" :"abc",
            "3" :"def",
            "4" :"ghi",
            "5" :"jkl",
            "6" :"mno",
            "7" :"pqrs",
            "8" :"tuv",
            "9" :"wxyz"
        }
        def traceback(index):
            # 结束条件：
            if index == len(digits):
                #注意： 这里要写成这样，如果直接.append(path), 会输出嵌套列表
                results.append("".join(path))
            else:
                #输入的数字
                d = digits[index]
                # 选择列表：
                for i in comprisedD[d]:
                #路径选择：
                    path.append(i)
                    traceback(index+1)
                    path.pop()

        path = list()
        results = list()
        traceback(0)
        return results
        
```
46.全排列（中等）  
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]  
输出:  
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        if not nums: 
            return list()
        def traceback(first = 0):
            if first == len(nums):
                # nums? 可能需要拷贝过程？ 
                results.append(nums[:])
            else: 
                for i in range(first, len(nums)):
                    #这里不用list是因为指针 first和i可能为同一个数会重复
                    nums[i],nums[first]=nums[first],nums[i]
                    traceback(first+1)
                    #恢复
                    nums[first],nums[i] = nums[i],nums[first]
                          
        results = list()
        traceback()
        return results

```  
51.N皇后（困难）  
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

 

示例 1：


输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]  
解释：如上图所示，4 皇后问题存在两个不同的解法。  
示例 2：

输入：n = 1
输出：[["Q"]]
 

提示：

1 <= n <= 9
皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-queens
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  
## list 和set的区别：  
https://blog.csdn.net/weixin_41082042/article/details/79127552#:~:text=%E9%9B%86%E5%90%88(set)%E6%98%AF%E4%B8%80%E4%B8%AA%E6%97%A0,%E7%9A%84%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E3%80%82&text=Python%E4%B8%ADlist%EF%BC%8Ctuple%EF%BC%8Cdict,%E5%92%8Cdict%E7%9A%84%E6%95%B0%E6%8D%AE...

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def generateBoard():
            board =list()
            for i in range(n):
                b[queens[i]] = "Q"
                board.append("".join(b))
                b[queens[i]] = "."
            return board

        def backtrack(row):
            if row == n:
                board = generateBoard()
                solutions.append(board)
            for i in range(n):
                if  i in columns or i-row in dignR or row + i in dignL:
                    continue
                #加到queens里
                queens[row] = i
                # 全新的添加进去：
                columns.add(i)
                dignL.add(row+i)
                dignR.add(i-row)
                #回溯
                backtrack(row+1)
                #去除
                columns.remove(i)
                dignL.remove(row+i)
                dignR.remove(i-row)
            
        solutions = list()
        queens = [-1]*n
        columns = set()
        dignR = set()
        dignL = set()
        b = ["."] * n
        
        backtrack(0)
        return solutions

```
