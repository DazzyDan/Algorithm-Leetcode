给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。  
示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"].   
示例 2：  

输入：digits = ""
输出：[].   
示例 3：  

输入：digits = "2"
输出：["a","b","c"]. 
 

提示：

0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

# 运用回溯法(Dfs)：  
## 回溯法： = 决策树的遍历过程  
考虑三个问题：  
* 路径：也就是*已经做出的选择*。
* 选择列表：也就是你当前*可以做的选择*。
* 结束条件：也就是到达决策树底层，*无法再做选择的*条件
## 框架：
```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择

```





# 解答：
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits :
            return list()
        comprisedD = {
            "2" :"abc",
            "3" :"def",
            "4" :"ghi",
            "5" :"jkl",
            "6" :"mno",
            "7" :"pqrs",
            "8" :"tuv",
            "9" :"wxyz"
        }
        def traceback(index):
            # 结束条件：
            if index == len(digits):
                #注意： 这里要写成这样，如果直接.append(path), 会输出嵌套列表
                results.append("".join(path))
            else:
                #输入的数字
                d = digits[index]
                # 选择列表：
                for i in comprisedD[d]:
                #路径选择：
                    path.append(i)
                    traceback(index+1)
                    path.pop()

        path = list()
        results = list()
        traceback(0)
        return results
        
```
46.全排列（中等）  
给定一个 没有重复 数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]  
输出:  
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        if not nums: 
            return list()
        def traceback(first = 0):
            if first == len(nums):
                # nums? 可能需要拷贝过程？ 
                results.append(nums[:])
            else: 
                for i in range(first, len(nums)):
                    #这里不用list是因为指针 first和i可能为同一个数会重复
                    nums[i],nums[first]=nums[first],nums[i]
                    traceback(first+1)
                    #恢复
                    nums[first],nums[i] = nums[i],nums[first]
                          
        results = list()
        traceback()
        return results

```  
51.N皇后（困难）  
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

 

示例 1：


输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]  
解释：如上图所示，4 皇后问题存在两个不同的解法。  
示例 2：

输入：n = 1
输出：[["Q"]]
 

提示：

1 <= n <= 9
皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/n-queens
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  
## list 和set的区别：  
https://blog.csdn.net/weixin_41082042/article/details/79127552#:~:text=%E9%9B%86%E5%90%88(set)%E6%98%AF%E4%B8%80%E4%B8%AA%E6%97%A0,%E7%9A%84%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E5%BA%8F%E5%88%97%E3%80%82&text=Python%E4%B8%ADlist%EF%BC%8Ctuple%EF%BC%8Cdict,%E5%92%8Cdict%E7%9A%84%E6%95%B0%E6%8D%AE...

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        def generateBoard():
            board =list()
            for i in range(n):
                b[queens[i]] = "Q"
                board.append("".join(b))
                b[queens[i]] = "."
            return board

        def backtrack(row):
            if row == n:
                board = generateBoard()
                solutions.append(board)
            for i in range(n):
                if  i in columns or i-row in dignR or row + i in dignL:
                    continue
                #加到queens里
                queens[row] = i
                # 全新的添加进去：
                columns.add(i)
                dignL.add(row+i)
                dignR.add(i-row)
                #回溯
                backtrack(row+1)
                #去除
                columns.remove(i)
                dignL.remove(row+i)
                dignR.remove(i-row)
            
        solutions = list()
        queens = [-1]*n
        columns = set()
        dignR = set()
        dignL = set()
        b = ["."] * n
        
        backtrack(0)
        return solutions

```

40. 组合总和 II
给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

注意：解集不能包含重复的组合。 

 

示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
示例 2:

输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
 
```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        def backtracking(first: int,result: List[int], target:int):        
            if target == 0:
                result.sort()
                if result not in solutions :
                    solutions.append(result[:])
                    result.clear()
                    return
            for i in range(first,len(candidates)):
                if target < candidates[i]:
                    break
                if i > first and candidates[i]==candidates[i-1]:
                    continue
                backtracking(i+1,result+[candidates[i]],target-candidates[i])
        solutions = []
        result = []
        first = 0
        candidates.sort()
        if sum(candidates) < target:
            return []
        backtracking(first,result,target)
        return solutions
```
解释语句: if cur > begin and candidates[cur-1] == candidates[cur] 是如何避免重复的。



这个避免重复当思想是在是太重要了。
这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即
                  1
                 / \
                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：
               /     \
              5       5
                例2
                  1
                 /
                2      这种情况确是允许的
               /
              2  
                
为何会有这种神奇的效果呢？
首先 cur-1 == cur 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。
可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 
因为当第二个2出现的时候，他就和前一个2相同了。
                
那么如何保留例2呢？
那么就用cur > begin 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，
例2的两个2是处在不同层级上的。
在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，
必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。
第一个出现的2的特点就是 cur == begin. 第二个出现的2 特点是cur > begin.
